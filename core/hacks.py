#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""DFHack management."""
from __future__ import print_function, unicode_literals, absolute_import

import os
from . import paths
from .lnp import lnp

def read_hacks():
    """Reads which hacks are enabled."""
    try:
        f = open(os.path.join(paths.get('df'), 'PyLNP_dfhack_onload.init'))
        hacklines = f.readlines()
        for h in get_hacks().values():
            h['enabled'] = h['command']+'\n' in hacklines
        f.close()
    except IOError:
        for h in get_hacks().values():
            h['enabled'] = False

def get_hacks():
    """Returns dict of available hacks."""
    return lnp.config.get_dict('dfhack')

def get_hack(title):
    """
    Returns the hack titled <title>, or None if this does not exist.

    Params:
        title
            The title of the hack.
    """
    try:
        return get_hacks()[title]
    except KeyError:
        return None

def toggle_hack(name):
    """
    Toggles the hack <name>.

    Params:
        name
            The name of the hack to toggle.
    """
    get_hack(name)['enabled'] = not get_hack(name)['enabled']
    rebuild_hacks()

def rebuild_hacks():
    """Rebuilds PyLNP_dfhack_onload.init with the enabled hacks."""
    f = open(os.path.join(paths.get('df'), 'PyLNP_dfhack_onload.init'), 'w')
    f.write('# Generated by PyLNP\n\n')
    for k, h in get_hacks().items():
        if h['enabled']:
            f.write('# '+str(k)+'\n')
            f.write('# '+str(h['tooltip'])+'\n')
            f.write(h['command']+'\n\n')
    f.flush()
    f.close()
